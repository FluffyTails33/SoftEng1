datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

model Role {
  id    String   @id @default(uuid())
  name  RoleName @unique
  users User[] // A role can have many users
}

enum RoleName {
  ADMIN
  CUSTOMER
}

// TODO: Just implement RBAC, no need for permissions
// model Permission {
//   id   String         @id @default(uuid())
//   name PermissionName @unique // A permission should have a unique name. i.e create, read, update, delete

//   roles Role[] // A permission can have many roles
// }

model User {
  id               String    @id @default(uuid())
  username         String    @unique
  email            String    @unique
  emailVerified    DateTime?
  phoneNumber      String?
  hashedPassword   String
  image            String? // This will serve as the user's avatar or profile picture
  userIsActive     Boolean   @default(true) // This is account duration active i.e x months active then set to false is more than x months
  accountActivated Boolean   @default(false) // This is to check if the user has activated their account using the email verification

  roleId       String
  restaurantId String? // This is nullable as not all users will be restaurant owners but an admin can create a restaurant 
  // cartId       String? // This is nullable as not all users will have a cart, only customers will have a cart
  // walletId     String? // This is nullable as not all users will have a wallet, only customers will have a wallet
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  role Role @relation(fields: [roleId], references: [id]) // A user can have one role

  cart             Cart?
  orders           Order[] // A user can have many orders
  wallet           Wallet?
  activationTokens ActivationToken[] // A user can have many activation tokens
  restaurants      Restaurant[] // An admin can have many restaurants

  @@index([roleId], name: "role_id")
}

model ActivationToken {
  id          String    @id @default(uuid())
  token       String    @unique
  activatedAt DateTime?

  userId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users User @relation(fields: [userId], references: [id])

  @@index([userId], name: "user_id")
}

model Cart {
  id     String @id @default(uuid())
  userId String // A cart is associated with a user

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User       @relation(fields: [userId], references: [id])
  cartItems CartItem[] // A cart can have many items

  @@unique([userId], name: "unique_user_id") // A user can only have one cart, reenforced by the unique constraint
  @@index([userId], name: "user_id")
}

model CartItem {
  id       String @id @default(uuid())
  quantity Int

  cartId    String
  productId String

  product Product @relation(fields: [productId], references: [id]) // A cart item is associated with a product
  cart    Cart    @relation(fields: [cartId], references: [id]) // A cart item is associated with a cart

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cartId], name: "cart_items_cart_id")
  @@index([productId], name: "cart_items_product_id")
}

// This model will represent the different categories of products, i.e drinks, foods, and will be used to group products i.e foods can have "pizza, burger, desserts, etc" as categories and drinks can have "soda, juice, , wine, , desserts, etc" as categories and desserts can have "ice cream, cake, etc" as categories and addons can have "cheese, bacon, etc" as categories. 
model Category {
  id   String @id @default(uuid())
  name String @unique(map: "unique_category_name")

  products Product[] // A category can have many products

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name], name: "unique_category_name") // A category should have a unique name
}

// Categories might be associated with different types, i.e drinks and foods product have similar categories, but overall have different properties associated with them, not important for now 

// This model will represent the overall order of a user and its information
model Order {
  id              String  @id @default(uuid())
  orderStatus     String
  // paymentMethod   String?
  shippingAddress String
  isPaid          Boolean @default(false)
  totalAmount     Decimal

  userId        String
  orderId       String
  transactionId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItems   OrderItem[] // An order can have many items
  users        User          @relation(fields: [userId], references: [id]) // An order is associated with a user
  transactions Transaction[] // An order can have multiple transactions on a single order

  @@index([userId], name: "user_id")
}

// This model will represent each individual item in an order
model OrderItem {
  id String @id @default(uuid())
  // quantity Int

  orderId   String
  productId String

  // createdAt DateTime @default(now())
  // updatedAt DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id]) // An order item is associated with a product
  order   Order   @relation(fields: [orderId], references: [id], map: "order_items_order_id") // An order item is associated with an order

  @@index([orderId], name: "order_items_order_id")
  @@index([productId], name: "order_items_product_id")
}

model Product {
  id          String  @id @default(uuid())
  name        String
  description String
  price       Decimal
  quantity    Int
  isPublished Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  categoryId String // Foreign Key

  images      Image[]
  inventory   Inventory[]
  cartItems   CartItem[] // A product can have many cart items
  orderItems  OrderItem[] // A product can have many order items
  category    Category    @relation(fields: [categoryId], references: [id]) // A product is associated with a category
  restaurants Restaurant  @relation("RestaurantToProduct", fields: [storeId], references: [id])
  storeId     String

  @@index([categoryId])
  @@index([storeId])
}

// This model will represent the images associated with a product
model Image {
  id  String @id @default(uuid())
  url String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productId String

  product Product @relation(fields: [productId], references: [id], map: "image_product_id") // An image is associated with a product

  @@index([productId], name: "image_product_id")
}

model Restaurant {
  id        String  @id @default(uuid())
  name      String
  userId    String
  address   String?
  logoImage String?

  inventory Inventory[] @relation("RestaurantToInventory")
  products  Product[]   @relation("RestaurantToProduct")
  foods     Food[]      @relation("RestaurantToFood")
  drinks    Drink[]     @relation("RestaurantToDrink")

  users User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Food {
  id          String  @id @default(uuid())
  name        String
  price       Decimal
  description String
  // available   Boolean @default(true)

  categoryId   String // Foreign Key
  addons       AddOn[] @relation("FoodToAddon") // A food can have many addons
  restaurantId String // Foreign Key

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  restaurants Restaurant @relation("RestaurantToFood", fields: [restaurantId], references: [id])
  // TODO: Create the relations 

  @@index([restaurantId])
}

model Drink {
  id          String  @id @default(uuid())
  name        String
  price       Decimal
  description String
  size        String

  categoryId   String // Foreign Key
  restaurantId String // Foreign Key

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  restaurants Restaurant @relation("RestaurantToDrink", fields: [restaurantId], references: [id])

  // TODO: Create the relations 

  @@index([restaurantId])
}

model AddOn {
  id    String  @id @default(uuid())
  name  String
  price Decimal

  categoryId String // Foreign Key

  foodId       String // Foreign Key
  restaurantId String // Foreign Key

  foods Food @relation("FoodToAddon", fields: [foodId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // TODO: Create the relations 

  @@index([foodId], name: "addon_food_id")
}

model Inventory {
  id String @id @default(uuid())

  productId String // Foreign Key

  // quantity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  restaurantId String // Foreign Key

  product     Product     @relation(fields: [productId], references: [id], map: "inventory_product_id") // An inventory is associated with a product
  restaurants Restaurant? @relation("RestaurantToInventory", fields: [restaurantId], references: [id])
  storeId     String?

  @@index([productId], name: "inventory_product_id")
  @@index([storeId])
  @@index([restaurantId])
}

// This model will represent the transaction associated with an order
model Transaction {
  id String @id @default(uuid())
  // transactionId     String

  totalAmount       Decimal
  transactionStatus String
  paymentMethod     String

  orderId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id])

  @@unique([orderId], name: "unique_order_id")
  @@index([orderId], name: "order_id")
}

model Wallet {
  id             String  @id @default(uuid())
  userId         String  @unique
  currentBalance Decimal @default(0)
  user           User    @relation(fields: [userId], references: [id])
}
