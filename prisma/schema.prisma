datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

enum RoleName {
  ADMIN
  CUSTOMER
}

enum PermissionName {
  CREATE
  READ
  UPDATE
  DELETE
}

//  This model will define the role of a user, i.e admin, customer, etc
model Role {
  id   String   @id @default(uuid())
  name RoleName @unique // A role should have a unique name. i.e admin, customer, etc

  permissions Permission[] // A role can have many permissions
  users       User[] // A role can have many users
}

model Permission {
  id   String         @id @default(uuid())
  name PermissionName @unique // A permission should have a unique name. i.e create, read, update, delete

  roles Role[] // A permission can have many roles
}

model User {
  id               String    @id @default(uuid())
  username         String    @unique
  email            String    @unique
  emailVerified    DateTime?
  phoneNumber      String?
  hashedPassword   String
  image            String? // This will serve as the user's avatar or profile picture
  userIsActive     Boolean   @default(true) // This is account duration active i.e x months active then set to false is more than x months
  accountActivated Boolean   @default(false) // This is to check if the user has activated their account using the email verification

  roleId    String?
  cartId    String?
  walletId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  role             Role?             @relation(fields: [roleId], references: [id]) // A user can have one role
  cart             Cart? // A user can have one cart
  orders           Order[] // A user can have many orders
  wallet           Wallet? // A user has wallet
  activationTokens ActivationToken[] // A user can have many activation tokens

  @@index([roleId], name: "role_id")
  @@index([cartId], name: "cart_id")
  @@index([walletId], name: "wallet_id")
}

model ActivationToken {
  id          String    @id @default(uuid())
  token       String    @unique
  activatedAt DateTime?

  userId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId], name: "user_id")
}

model Cart {
  id     String @id @default(uuid())
  userId String // A cart is associated with a user

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cartItems CartItem[] // A cart can have many items
  users     User       @relation(fields: [userId], references: [id]) // A cart is only associated with one user

  @@unique([userId], name: "unique_user_id") // A user can only have one cart, reenforced by the unique constraint
  @@index([userId], name: "user_id")
}

model CartItem {
  id       String @id @default(uuid())
  quantity Int

  cartId    String
  productId String

  product Product @relation(fields: [productId], references: [id]) // A cart item is associated with a product
  cart    Cart    @relation(fields: [cartId], references: [id]) // A cart item is associated with a cart

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cartId], name: "cart_items_cart_id")
  @@index([productId], name: "cart_items_product_id")
}

model Category {
  id   String @id @default(uuid())
  name String @unique(map: "unique_category_name")

  products Product[] // A category can have many products

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name], name: "unique_category_name") // A category should have a unique name
}

// Categories might be associated with different types, i.e drinks and foods product have similar categories, but overall have different properties associated with them, not important for now 

// This model will represent the overall order of a user and its information
model Order {
  id              String  @id @default(uuid())
  orderStatus     String
  // paymentMethod   String?
  shippingAddress String  @default("No address provided")
  isPaid          Boolean @default(false)
  totalAmount     Decimal

  userId        String
  orderId       String
  transactionId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItems  OrderItem[] // An order can have many items
  users       User          @relation(fields: [userId], references: [id]) // An order is associated with a user
  transaction Transaction[] // An order can have multiple transactions on a single order

  @@index([userId], name: "user_id")
}

// This model will represent each individual item in an order
model OrderItem {
  id String @id @default(uuid())
  // quantity Int

  orderId   String
  productId String

  // createdAt DateTime @default(now())
  // updatedAt DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id]) // An order item is associated with a product
  order   Order   @relation(fields: [orderId], references: [id], map: "order_items_order_id") // An order item is associated with an order

  @@index([orderId], name: "order_items_order_id")
  @@index([productId], name: "order_items_product_id")
}

model Product {
  id          String  @id @default(uuid())
  name        String
  description String
  price       Decimal
  quantity    Int
  published   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  categoryId String // Foreign Key

  images     Image[]
  inventory  Inventory[]
  cartItems  CartItem[] // A product can have many cart items
  orderItems OrderItem[] // A product can have many order items
  category   Category    @relation(fields: [categoryId], references: [id]) // A product is associated with a category
  store      Store       @relation(fields: [storeId], references: [id])
  storeId    String

  @@index([categoryId])
  @@index([storeId])
}

// This model will represent the images associated with a product
model Image {
  id  String @id @default(uuid())
  url String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productId String

  product Product @relation(fields: [productId], references: [id], map: "image_product_id") // An image is associated with a product

  @@index([productId], name: "image_product_id")
}

model Store {
  id        String @id @default(uuid())
  name      String
  userId    String
  address   String
  logoImage String

  inventory Inventory[]
  products  Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Inventory {
  id String @id @default(uuid())

  productId String // Foreign Key

  // quantity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id], map: "inventory_product_id") // An inventory is associated with a product
  Store   Store?  @relation(fields: [storeId], references: [id])
  storeId String?

  @@index([productId], name: "inventory_product_id")
  @@index([storeId])
}

// This model will represent the transaction associated with an order
model Transaction {
  id String @id @default(uuid())
  // transactionId     String

  totalAmount       Decimal
  transactionStatus String
  paymentMethod     String

  orderId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id])

  @@unique([orderId], name: "unique_order_id")
  @@index([orderId], name: "order_id")
}

model Wallet {
  id             String  @id @default(uuid())
  userId         String
  currentBalance Decimal @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@unique([userId], name: "unique_user_id")
  @@index([userId], name: "user_id")
}
